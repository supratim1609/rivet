/// Generates Flutter/Dart API client from route definitions
library;

import 'models.dart';

/// Generates a complete Dart API client class
class ClientGenerator {
  /// Generate the complete client file
  String generate({
    required List<RouteDefinition> routes,
    required List<TypeDefinition> types,
    String className = 'RivetClient',
  }) {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// AUTO-GENERATED CODE - DO NOT EDIT');
    buffer.writeln('// Generated by Rivet Code Generator');
    buffer.writeln('// Generated at: ${DateTime.now()}');
    buffer.writeln();

    // Imports
    buffer.writeln('import \'dart:convert\';');
    buffer.writeln('import \'package:http/http.dart\' as http;');
    buffer.writeln();

    // Generate model classes first
    for (final type in types) {
      buffer.writeln(_generateModel(type));
      buffer.writeln();
    }

    // Generate client class
    buffer.writeln(_generateClientClass(className, routes));

    // Generate exception class
    buffer.writeln();
    buffer.writeln(_generateExceptionClass());

    return buffer.toString();
  }

  String _generateModel(TypeDefinition type) {
    final buffer = StringBuffer();

    buffer.writeln('class ${type.name} {');

    // Fields
    type.fields.forEach((name, field) {
      buffer.writeln('  final ${field.fullType} $name;');
    });

    buffer.writeln();

    // Constructor
    buffer.write('  ${type.name}({');
    final requiredFields = type.fields.entries
        .where((e) => !e.value.isNullable)
        .map((e) => 'required this.${e.key}');
    final optionalFields = type.fields.entries
        .where((e) => e.value.isNullable)
        .map((e) => 'this.${e.key}');

    buffer.write(requiredFields.join(', '));
    if (requiredFields.isNotEmpty && optionalFields.isNotEmpty) {
      buffer.write(', ');
    }
    buffer.write(optionalFields.join(', '));
    buffer.writeln('});');

    buffer.writeln();

    // fromJson
    buffer.writeln(
        '  factory ${type.name}.fromJson(Map<String, dynamic> json) {');
    buffer.writeln('    return ${type.name}(');

    type.fields.forEach((name, field) {
      if (field.isList) {
        if (_isPrimitive(field.dartType)) {
          buffer.writeln(
              '      $name: (json[\'$name\'] as List<dynamic>).cast<${field.dartType}>(),');
        } else {
          buffer.writeln(
              '      $name: (json[\'$name\'] as List<dynamic>).map((e) => ${field.dartType}.fromJson(e as Map<String, dynamic>)).toList(),');
        }
      } else if (_isPrimitive(field.dartType)) {
        buffer.writeln('      $name: json[\'$name\'] as ${field.fullType},');
      } else {
        if (field.isNullable) {
          buffer.writeln(
              '      $name: json[\'$name\'] != null ? ${field.dartType}.fromJson(json[\'$name\'] as Map<String, dynamic>) : null,');
        } else {
          buffer.writeln(
              '      $name: ${field.dartType}.fromJson(json[\'$name\'] as Map<String, dynamic>),');
        }
      }
    });

    buffer.writeln('    );');
    buffer.writeln('  }');

    buffer.writeln();

    // toJson
    buffer.writeln('  Map<String, dynamic> toJson() {');
    buffer.writeln('    return {');

    type.fields.forEach((name, field) {
      if (field.isList && !_isPrimitive(field.dartType)) {
        buffer.writeln('      \'$name\': $name.map((e) => e.toJson()).toList(),');
      } else if (!_isPrimitive(field.dartType) && !field.isNullable) {
        buffer.writeln('      \'$name\': $name.toJson(),');
      } else if (!_isPrimitive(field.dartType) && field.isNullable) {
        buffer.writeln('      \'$name\': $name?.toJson(),');
      } else {
        buffer.writeln('      \'$name\': $name,');
      }
    });

    buffer.writeln('    };');
    buffer.writeln('  }');

    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateClientClass(String className, List<RouteDefinition> routes) {
    final buffer = StringBuffer();

    buffer.writeln('class $className {');
    buffer.writeln('  final String baseUrl;');
    buffer.writeln('  final http.Client _client;');
    buffer.writeln('  final Map<String, String> _defaultHeaders;');
    buffer.writeln();
    buffer.writeln('  $className(');
    buffer.writeln('    this.baseUrl, {');
    buffer.writeln('    http.Client? client,');
    buffer.writeln('    Map<String, String>? defaultHeaders,');
    buffer.writeln('  })  : _client = client ?? http.Client(),');
    buffer.writeln('        _defaultHeaders = defaultHeaders ?? {};');
    buffer.writeln();

    // Generate method for each route
    for (final route in routes) {
      buffer.writeln(_generateMethod(route));
      buffer.writeln();
    }

    // Close method
    buffer.writeln('  void close() {');
    buffer.writeln('    _client.close();');
    buffer.writeln('  }');

    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateMethod(RouteDefinition route) {
    final buffer = StringBuffer();

    // Method signature
    final returnType = _getReturnType(route.responseType);
    buffer.write('  Future<$returnType> ${route.methodName}(');

    // Parameters
    final params = <String>[];

    // Path parameters
    for (final param in route.pathParams) {
      params.add('{required String $param}');
    }

    // Query parameters
    route.queryParams.forEach((name, type) {
      params.add('{$type? $name}');
    });

    // Request body (for POST/PUT)
    if (route.requestBodyType != null) {
      params.add('{required ${route.requestBodyType} body}');
    }

    buffer.write(params.join(', '));
    buffer.writeln(') async {');

    // Build URL
    var urlPath = route.path;
    for (final param in route.pathParams) {
      urlPath = urlPath.replaceAll(':$param', '\$$param');
    }

    buffer.writeln('    var url = Uri.parse(\'\$baseUrl$urlPath\');');

    // Add query parameters
    if (route.queryParams.isNotEmpty) {
      buffer.writeln('    final queryParams = <String, String>{};');
      route.queryParams.forEach((name, _) {
        buffer.writeln('    if ($name != null) queryParams[\'$name\'] = $name.toString();');
      });
      buffer.writeln('    if (queryParams.isNotEmpty) {');
      buffer.writeln('      url = url.replace(queryParameters: queryParams);');
      buffer.writeln('    }');
    }

    // Make HTTP request
    final method = route.method.toLowerCase();
    buffer.writeln();
    buffer.writeln('    final headers = {..._defaultHeaders};');
    
    if (route.requestBodyType != null) {
      buffer.writeln('    headers[\'Content-Type\'] = \'application/json\';');
      buffer.writeln();
      buffer.writeln('    final response = await _client.$method(');
      buffer.writeln('      url,');
      buffer.writeln('      headers: headers,');
      buffer.writeln('      body: jsonEncode(body.toJson()),');
      buffer.writeln('    );');
    } else {
      buffer.writeln();
      buffer.writeln('    final response = await _client.$method(url, headers: headers);');
    }

    // Handle response
    buffer.writeln();
    buffer.writeln('    if (response.statusCode >= 200 && response.statusCode < 300) {');
    buffer.writeln('      final json = jsonDecode(response.body);');
    
    if (route.responseType.startsWith('List<')) {
      final innerType = route.responseType.substring(5, route.responseType.length - 1);
      buffer.writeln('      return (json as List<dynamic>)');
      buffer.writeln('          .map((e) => $innerType.fromJson(e as Map<String, dynamic>))');
      buffer.writeln('          .toList();');
    } else if (_isPrimitive(route.responseType)) {
      buffer.writeln('      return json as $returnType;');
    } else {
      buffer.writeln('      return ${route.responseType}.fromJson(json as Map<String, dynamic>);');
    }
    
    buffer.writeln('    } else {');
    buffer.writeln('      throw RivetClientException(');
    buffer.writeln('        response.statusCode,');
    buffer.writeln('        response.body,');
    buffer.writeln('      );');
    buffer.writeln('    }');

    buffer.writeln('  }');

    return buffer.toString();
  }

  String _getReturnType(String responseType) {
    return responseType;
  }

  String _generateExceptionClass() {
    return '''
class RivetClientException implements Exception {
  final int statusCode;
  final String body;

  RivetClientException(this.statusCode, this.body);

  @override
  String toString() => 'RivetClientException(\$statusCode): \$body';
}''';
  }

  bool _isPrimitive(String type) {
    return ['String', 'int', 'double', 'bool', 'dynamic', 'Map<String, dynamic>']
        .contains(type);
  }
}
